<?php
/**
 * EventsApi
 * PHP version 7.3
 *
 * @category Class
 * @package  ElasticEmail
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Elastic Email REST API
 *
 * This API is based on the REST API architecture, allowing the user to easily manage their data with this resource-based approach.    Every API call is established on which specific request type (GET, POST, PUT, DELETE) will be used.    The API has a limit of 20 concurrent connections and a hard timeout of 600 seconds per request.    To start using this API, you will need your Access Token (available <a target=\"_blank\" href=\"https://elasticemail.com/account#/settings/new/manage-api\">here</a>). Remember to keep it safe. Required access levels are listed in the given request’s description.    This is the documentation for REST API. If you’d like to read our legacy documentation regarding Web API v2 click <a target=\"_blank\" href=\"https://api.elasticemail.com/public/help\">here</a>.    Downloadable library clients can be found in our Github repository <a target=\"_blank\" href=\"https://github.com/ElasticEmail?tab=repositories&q=%22rest+api%22+in%3Areadme\">here</a>
 *
 * The version of the OpenAPI document: 4.0.0
 * Contact: support@elasticemail.com
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.3.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace ElasticEmail\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use ElasticEmail\ApiException;
use ElasticEmail\Configuration;
use ElasticEmail\HeaderSelector;
use ElasticEmail\ObjectSerializer;

/**
 * EventsApi Class Doc Comment
 *
 * @category Class
 * @package  ElasticEmail
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class EventsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation eventsByTransactionidGet
     *
     * Load Email Events
     *
     * @param  string $transactionid ID number of transaction (required)
     * @param  \DateTime $from Starting date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \DateTime $to Ending date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \ElasticEmail\Model\EventsOrderBy $order_by order_by (optional)
     * @param  int $limit Maximum number of returned items. (optional)
     * @param  int $offset How many items should be returned ahead. (optional)
     *
     * @throws \ElasticEmail\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ElasticEmail\Model\RecipientEvent[]
     */
    public function eventsByTransactionidGet($transactionid, $from = null, $to = null, $order_by = null, $limit = null, $offset = null)
    {
        list($response) = $this->eventsByTransactionidGetWithHttpInfo($transactionid, $from, $to, $order_by, $limit, $offset);
        return $response;
    }

    /**
     * Operation eventsByTransactionidGetWithHttpInfo
     *
     * Load Email Events
     *
     * @param  string $transactionid ID number of transaction (required)
     * @param  \DateTime $from Starting date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \DateTime $to Ending date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \ElasticEmail\Model\EventsOrderBy $order_by (optional)
     * @param  int $limit Maximum number of returned items. (optional)
     * @param  int $offset How many items should be returned ahead. (optional)
     *
     * @throws \ElasticEmail\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ElasticEmail\Model\RecipientEvent[], HTTP status code, HTTP response headers (array of strings)
     */
    public function eventsByTransactionidGetWithHttpInfo($transactionid, $from = null, $to = null, $order_by = null, $limit = null, $offset = null)
    {
        $request = $this->eventsByTransactionidGetRequest($transactionid, $from, $to, $order_by, $limit, $offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ElasticEmail\Model\RecipientEvent[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ElasticEmail\Model\RecipientEvent[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ElasticEmail\Model\RecipientEvent[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ElasticEmail\Model\RecipientEvent[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation eventsByTransactionidGetAsync
     *
     * Load Email Events
     *
     * @param  string $transactionid ID number of transaction (required)
     * @param  \DateTime $from Starting date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \DateTime $to Ending date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \ElasticEmail\Model\EventsOrderBy $order_by (optional)
     * @param  int $limit Maximum number of returned items. (optional)
     * @param  int $offset How many items should be returned ahead. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventsByTransactionidGetAsync($transactionid, $from = null, $to = null, $order_by = null, $limit = null, $offset = null)
    {
        return $this->eventsByTransactionidGetAsyncWithHttpInfo($transactionid, $from, $to, $order_by, $limit, $offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation eventsByTransactionidGetAsyncWithHttpInfo
     *
     * Load Email Events
     *
     * @param  string $transactionid ID number of transaction (required)
     * @param  \DateTime $from Starting date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \DateTime $to Ending date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \ElasticEmail\Model\EventsOrderBy $order_by (optional)
     * @param  int $limit Maximum number of returned items. (optional)
     * @param  int $offset How many items should be returned ahead. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventsByTransactionidGetAsyncWithHttpInfo($transactionid, $from = null, $to = null, $order_by = null, $limit = null, $offset = null)
    {
        $returnType = '\ElasticEmail\Model\RecipientEvent[]';
        $request = $this->eventsByTransactionidGetRequest($transactionid, $from, $to, $order_by, $limit, $offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'eventsByTransactionidGet'
     *
     * @param  string $transactionid ID number of transaction (required)
     * @param  \DateTime $from Starting date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \DateTime $to Ending date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \ElasticEmail\Model\EventsOrderBy $order_by (optional)
     * @param  int $limit Maximum number of returned items. (optional)
     * @param  int $offset How many items should be returned ahead. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function eventsByTransactionidGetRequest($transactionid, $from = null, $to = null, $order_by = null, $limit = null, $offset = null)
    {
        // verify the required parameter 'transactionid' is set
        if ($transactionid === null || (is_array($transactionid) && count($transactionid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $transactionid when calling eventsByTransactionidGet'
            );
        }

        $resourcePath = '/events/{transactionid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }
        // query params
        if ($order_by !== null) {
            if('form' === 'form' && is_array($order_by)) {
                foreach($order_by as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['orderBy'] = $order_by;
            }
        }
        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }
        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }


        // path params
        if ($transactionid !== null) {
            $resourcePath = str_replace(
                '{' . 'transactionid' . '}',
                ObjectSerializer::toPathValue($transactionid),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-ElasticEmail-ApiKey');
        if ($apiKey !== null) {
            $headers['X-ElasticEmail-ApiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation eventsChannelsByNameExportPost
     *
     * Export Channel Events
     *
     * @param  string $name Name of selected channel. (required)
     * @param  \ElasticEmail\Model\EventType[] $event_types Types of Events to return (optional)
     * @param  \DateTime $from Starting date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \DateTime $to Ending date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \ElasticEmail\Model\ExportFileFormats $file_format Format of the exported file (optional)
     * @param  \ElasticEmail\Model\CompressionFormat $compression_format FileResponse compression format. None or Zip. (optional)
     * @param  string $file_name Name of your file including extension. (optional)
     *
     * @throws \ElasticEmail\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ElasticEmail\Model\ExportLink
     */
    public function eventsChannelsByNameExportPost($name, $event_types = null, $from = null, $to = null, $file_format = null, $compression_format = null, $file_name = null)
    {
        list($response) = $this->eventsChannelsByNameExportPostWithHttpInfo($name, $event_types, $from, $to, $file_format, $compression_format, $file_name);
        return $response;
    }

    /**
     * Operation eventsChannelsByNameExportPostWithHttpInfo
     *
     * Export Channel Events
     *
     * @param  string $name Name of selected channel. (required)
     * @param  \ElasticEmail\Model\EventType[] $event_types Types of Events to return (optional)
     * @param  \DateTime $from Starting date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \DateTime $to Ending date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \ElasticEmail\Model\ExportFileFormats $file_format Format of the exported file (optional)
     * @param  \ElasticEmail\Model\CompressionFormat $compression_format FileResponse compression format. None or Zip. (optional)
     * @param  string $file_name Name of your file including extension. (optional)
     *
     * @throws \ElasticEmail\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ElasticEmail\Model\ExportLink, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventsChannelsByNameExportPostWithHttpInfo($name, $event_types = null, $from = null, $to = null, $file_format = null, $compression_format = null, $file_name = null)
    {
        $request = $this->eventsChannelsByNameExportPostRequest($name, $event_types, $from, $to, $file_format, $compression_format, $file_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 202:
                    if ('\ElasticEmail\Model\ExportLink' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ElasticEmail\Model\ExportLink', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ElasticEmail\Model\ExportLink';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ElasticEmail\Model\ExportLink',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation eventsChannelsByNameExportPostAsync
     *
     * Export Channel Events
     *
     * @param  string $name Name of selected channel. (required)
     * @param  \ElasticEmail\Model\EventType[] $event_types Types of Events to return (optional)
     * @param  \DateTime $from Starting date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \DateTime $to Ending date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \ElasticEmail\Model\ExportFileFormats $file_format Format of the exported file (optional)
     * @param  \ElasticEmail\Model\CompressionFormat $compression_format FileResponse compression format. None or Zip. (optional)
     * @param  string $file_name Name of your file including extension. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventsChannelsByNameExportPostAsync($name, $event_types = null, $from = null, $to = null, $file_format = null, $compression_format = null, $file_name = null)
    {
        return $this->eventsChannelsByNameExportPostAsyncWithHttpInfo($name, $event_types, $from, $to, $file_format, $compression_format, $file_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation eventsChannelsByNameExportPostAsyncWithHttpInfo
     *
     * Export Channel Events
     *
     * @param  string $name Name of selected channel. (required)
     * @param  \ElasticEmail\Model\EventType[] $event_types Types of Events to return (optional)
     * @param  \DateTime $from Starting date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \DateTime $to Ending date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \ElasticEmail\Model\ExportFileFormats $file_format Format of the exported file (optional)
     * @param  \ElasticEmail\Model\CompressionFormat $compression_format FileResponse compression format. None or Zip. (optional)
     * @param  string $file_name Name of your file including extension. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventsChannelsByNameExportPostAsyncWithHttpInfo($name, $event_types = null, $from = null, $to = null, $file_format = null, $compression_format = null, $file_name = null)
    {
        $returnType = '\ElasticEmail\Model\ExportLink';
        $request = $this->eventsChannelsByNameExportPostRequest($name, $event_types, $from, $to, $file_format, $compression_format, $file_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'eventsChannelsByNameExportPost'
     *
     * @param  string $name Name of selected channel. (required)
     * @param  \ElasticEmail\Model\EventType[] $event_types Types of Events to return (optional)
     * @param  \DateTime $from Starting date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \DateTime $to Ending date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \ElasticEmail\Model\ExportFileFormats $file_format Format of the exported file (optional)
     * @param  \ElasticEmail\Model\CompressionFormat $compression_format FileResponse compression format. None or Zip. (optional)
     * @param  string $file_name Name of your file including extension. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function eventsChannelsByNameExportPostRequest($name, $event_types = null, $from = null, $to = null, $file_format = null, $compression_format = null, $file_name = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling eventsChannelsByNameExportPost'
            );
        }

        $resourcePath = '/events/channels/{name}/export';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($event_types !== null) {
            if('form' === 'form' && is_array($event_types)) {
                foreach($event_types as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['eventTypes'] = $event_types;
            }
        }
        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }
        // query params
        if ($file_format !== null) {
            if('form' === 'form' && is_array($file_format)) {
                foreach($file_format as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['fileFormat'] = $file_format;
            }
        }
        // query params
        if ($compression_format !== null) {
            if('form' === 'form' && is_array($compression_format)) {
                foreach($compression_format as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['compressionFormat'] = $compression_format;
            }
        }
        // query params
        if ($file_name !== null) {
            if('form' === 'form' && is_array($file_name)) {
                foreach($file_name as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['fileName'] = $file_name;
            }
        }


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-ElasticEmail-ApiKey');
        if ($apiKey !== null) {
            $headers['X-ElasticEmail-ApiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation eventsChannelsByNameGet
     *
     * Load Channel Events
     *
     * @param  string $name Name of selected channel. (required)
     * @param  \ElasticEmail\Model\EventType[] $event_types Types of Events to return (optional)
     * @param  \DateTime $from Starting date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \DateTime $to Ending date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \ElasticEmail\Model\EventsOrderBy $order_by order_by (optional)
     * @param  int $limit How many items to load. Maximum for this request is 1000 items (optional)
     * @param  int $offset How many items should be returned ahead. (optional)
     *
     * @throws \ElasticEmail\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ElasticEmail\Model\RecipientEvent[]
     */
    public function eventsChannelsByNameGet($name, $event_types = null, $from = null, $to = null, $order_by = null, $limit = null, $offset = null)
    {
        list($response) = $this->eventsChannelsByNameGetWithHttpInfo($name, $event_types, $from, $to, $order_by, $limit, $offset);
        return $response;
    }

    /**
     * Operation eventsChannelsByNameGetWithHttpInfo
     *
     * Load Channel Events
     *
     * @param  string $name Name of selected channel. (required)
     * @param  \ElasticEmail\Model\EventType[] $event_types Types of Events to return (optional)
     * @param  \DateTime $from Starting date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \DateTime $to Ending date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \ElasticEmail\Model\EventsOrderBy $order_by (optional)
     * @param  int $limit How many items to load. Maximum for this request is 1000 items (optional)
     * @param  int $offset How many items should be returned ahead. (optional)
     *
     * @throws \ElasticEmail\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ElasticEmail\Model\RecipientEvent[], HTTP status code, HTTP response headers (array of strings)
     */
    public function eventsChannelsByNameGetWithHttpInfo($name, $event_types = null, $from = null, $to = null, $order_by = null, $limit = null, $offset = null)
    {
        $request = $this->eventsChannelsByNameGetRequest($name, $event_types, $from, $to, $order_by, $limit, $offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ElasticEmail\Model\RecipientEvent[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ElasticEmail\Model\RecipientEvent[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ElasticEmail\Model\RecipientEvent[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ElasticEmail\Model\RecipientEvent[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation eventsChannelsByNameGetAsync
     *
     * Load Channel Events
     *
     * @param  string $name Name of selected channel. (required)
     * @param  \ElasticEmail\Model\EventType[] $event_types Types of Events to return (optional)
     * @param  \DateTime $from Starting date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \DateTime $to Ending date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \ElasticEmail\Model\EventsOrderBy $order_by (optional)
     * @param  int $limit How many items to load. Maximum for this request is 1000 items (optional)
     * @param  int $offset How many items should be returned ahead. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventsChannelsByNameGetAsync($name, $event_types = null, $from = null, $to = null, $order_by = null, $limit = null, $offset = null)
    {
        return $this->eventsChannelsByNameGetAsyncWithHttpInfo($name, $event_types, $from, $to, $order_by, $limit, $offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation eventsChannelsByNameGetAsyncWithHttpInfo
     *
     * Load Channel Events
     *
     * @param  string $name Name of selected channel. (required)
     * @param  \ElasticEmail\Model\EventType[] $event_types Types of Events to return (optional)
     * @param  \DateTime $from Starting date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \DateTime $to Ending date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \ElasticEmail\Model\EventsOrderBy $order_by (optional)
     * @param  int $limit How many items to load. Maximum for this request is 1000 items (optional)
     * @param  int $offset How many items should be returned ahead. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventsChannelsByNameGetAsyncWithHttpInfo($name, $event_types = null, $from = null, $to = null, $order_by = null, $limit = null, $offset = null)
    {
        $returnType = '\ElasticEmail\Model\RecipientEvent[]';
        $request = $this->eventsChannelsByNameGetRequest($name, $event_types, $from, $to, $order_by, $limit, $offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'eventsChannelsByNameGet'
     *
     * @param  string $name Name of selected channel. (required)
     * @param  \ElasticEmail\Model\EventType[] $event_types Types of Events to return (optional)
     * @param  \DateTime $from Starting date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \DateTime $to Ending date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \ElasticEmail\Model\EventsOrderBy $order_by (optional)
     * @param  int $limit How many items to load. Maximum for this request is 1000 items (optional)
     * @param  int $offset How many items should be returned ahead. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function eventsChannelsByNameGetRequest($name, $event_types = null, $from = null, $to = null, $order_by = null, $limit = null, $offset = null)
    {
        // verify the required parameter 'name' is set
        if ($name === null || (is_array($name) && count($name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $name when calling eventsChannelsByNameGet'
            );
        }

        $resourcePath = '/events/channels/{name}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($event_types !== null) {
            if('form' === 'form' && is_array($event_types)) {
                foreach($event_types as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['eventTypes'] = $event_types;
            }
        }
        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }
        // query params
        if ($order_by !== null) {
            if('form' === 'form' && is_array($order_by)) {
                foreach($order_by as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['orderBy'] = $order_by;
            }
        }
        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }
        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }


        // path params
        if ($name !== null) {
            $resourcePath = str_replace(
                '{' . 'name' . '}',
                ObjectSerializer::toPathValue($name),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-ElasticEmail-ApiKey');
        if ($apiKey !== null) {
            $headers['X-ElasticEmail-ApiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation eventsChannelsExportByIdStatusGet
     *
     * Check Channel Export Status
     *
     * @param  string $id ID of the exported file (required)
     *
     * @throws \ElasticEmail\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ElasticEmail\Model\ExportStatus
     */
    public function eventsChannelsExportByIdStatusGet($id)
    {
        list($response) = $this->eventsChannelsExportByIdStatusGetWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation eventsChannelsExportByIdStatusGetWithHttpInfo
     *
     * Check Channel Export Status
     *
     * @param  string $id ID of the exported file (required)
     *
     * @throws \ElasticEmail\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ElasticEmail\Model\ExportStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventsChannelsExportByIdStatusGetWithHttpInfo($id)
    {
        $request = $this->eventsChannelsExportByIdStatusGetRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ElasticEmail\Model\ExportStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ElasticEmail\Model\ExportStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ElasticEmail\Model\ExportStatus';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ElasticEmail\Model\ExportStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation eventsChannelsExportByIdStatusGetAsync
     *
     * Check Channel Export Status
     *
     * @param  string $id ID of the exported file (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventsChannelsExportByIdStatusGetAsync($id)
    {
        return $this->eventsChannelsExportByIdStatusGetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation eventsChannelsExportByIdStatusGetAsyncWithHttpInfo
     *
     * Check Channel Export Status
     *
     * @param  string $id ID of the exported file (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventsChannelsExportByIdStatusGetAsyncWithHttpInfo($id)
    {
        $returnType = '\ElasticEmail\Model\ExportStatus';
        $request = $this->eventsChannelsExportByIdStatusGetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'eventsChannelsExportByIdStatusGet'
     *
     * @param  string $id ID of the exported file (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function eventsChannelsExportByIdStatusGetRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling eventsChannelsExportByIdStatusGet'
            );
        }

        $resourcePath = '/events/channels/export/{id}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-ElasticEmail-ApiKey');
        if ($apiKey !== null) {
            $headers['X-ElasticEmail-ApiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation eventsExportByIdStatusGet
     *
     * Check Export Status
     *
     * @param  string $id ID of the exported file (required)
     *
     * @throws \ElasticEmail\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ElasticEmail\Model\ExportStatus
     */
    public function eventsExportByIdStatusGet($id)
    {
        list($response) = $this->eventsExportByIdStatusGetWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation eventsExportByIdStatusGetWithHttpInfo
     *
     * Check Export Status
     *
     * @param  string $id ID of the exported file (required)
     *
     * @throws \ElasticEmail\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ElasticEmail\Model\ExportStatus, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventsExportByIdStatusGetWithHttpInfo($id)
    {
        $request = $this->eventsExportByIdStatusGetRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ElasticEmail\Model\ExportStatus' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ElasticEmail\Model\ExportStatus', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ElasticEmail\Model\ExportStatus';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ElasticEmail\Model\ExportStatus',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation eventsExportByIdStatusGetAsync
     *
     * Check Export Status
     *
     * @param  string $id ID of the exported file (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventsExportByIdStatusGetAsync($id)
    {
        return $this->eventsExportByIdStatusGetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation eventsExportByIdStatusGetAsyncWithHttpInfo
     *
     * Check Export Status
     *
     * @param  string $id ID of the exported file (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventsExportByIdStatusGetAsyncWithHttpInfo($id)
    {
        $returnType = '\ElasticEmail\Model\ExportStatus';
        $request = $this->eventsExportByIdStatusGetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'eventsExportByIdStatusGet'
     *
     * @param  string $id ID of the exported file (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function eventsExportByIdStatusGetRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling eventsExportByIdStatusGet'
            );
        }

        $resourcePath = '/events/export/{id}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-ElasticEmail-ApiKey');
        if ($apiKey !== null) {
            $headers['X-ElasticEmail-ApiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation eventsExportPost
     *
     * Export Events
     *
     * @param  \ElasticEmail\Model\EventType[] $event_types Types of Events to return (optional)
     * @param  \DateTime $from Starting date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \DateTime $to Ending date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \ElasticEmail\Model\ExportFileFormats $file_format Format of the exported file (optional)
     * @param  \ElasticEmail\Model\CompressionFormat $compression_format FileResponse compression format. None or Zip. (optional)
     * @param  string $file_name Name of your file including extension. (optional)
     *
     * @throws \ElasticEmail\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ElasticEmail\Model\ExportLink
     */
    public function eventsExportPost($event_types = null, $from = null, $to = null, $file_format = null, $compression_format = null, $file_name = null)
    {
        list($response) = $this->eventsExportPostWithHttpInfo($event_types, $from, $to, $file_format, $compression_format, $file_name);
        return $response;
    }

    /**
     * Operation eventsExportPostWithHttpInfo
     *
     * Export Events
     *
     * @param  \ElasticEmail\Model\EventType[] $event_types Types of Events to return (optional)
     * @param  \DateTime $from Starting date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \DateTime $to Ending date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \ElasticEmail\Model\ExportFileFormats $file_format Format of the exported file (optional)
     * @param  \ElasticEmail\Model\CompressionFormat $compression_format FileResponse compression format. None or Zip. (optional)
     * @param  string $file_name Name of your file including extension. (optional)
     *
     * @throws \ElasticEmail\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ElasticEmail\Model\ExportLink, HTTP status code, HTTP response headers (array of strings)
     */
    public function eventsExportPostWithHttpInfo($event_types = null, $from = null, $to = null, $file_format = null, $compression_format = null, $file_name = null)
    {
        $request = $this->eventsExportPostRequest($event_types, $from, $to, $file_format, $compression_format, $file_name);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 202:
                    if ('\ElasticEmail\Model\ExportLink' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ElasticEmail\Model\ExportLink', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ElasticEmail\Model\ExportLink';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ElasticEmail\Model\ExportLink',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation eventsExportPostAsync
     *
     * Export Events
     *
     * @param  \ElasticEmail\Model\EventType[] $event_types Types of Events to return (optional)
     * @param  \DateTime $from Starting date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \DateTime $to Ending date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \ElasticEmail\Model\ExportFileFormats $file_format Format of the exported file (optional)
     * @param  \ElasticEmail\Model\CompressionFormat $compression_format FileResponse compression format. None or Zip. (optional)
     * @param  string $file_name Name of your file including extension. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventsExportPostAsync($event_types = null, $from = null, $to = null, $file_format = null, $compression_format = null, $file_name = null)
    {
        return $this->eventsExportPostAsyncWithHttpInfo($event_types, $from, $to, $file_format, $compression_format, $file_name)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation eventsExportPostAsyncWithHttpInfo
     *
     * Export Events
     *
     * @param  \ElasticEmail\Model\EventType[] $event_types Types of Events to return (optional)
     * @param  \DateTime $from Starting date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \DateTime $to Ending date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \ElasticEmail\Model\ExportFileFormats $file_format Format of the exported file (optional)
     * @param  \ElasticEmail\Model\CompressionFormat $compression_format FileResponse compression format. None or Zip. (optional)
     * @param  string $file_name Name of your file including extension. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventsExportPostAsyncWithHttpInfo($event_types = null, $from = null, $to = null, $file_format = null, $compression_format = null, $file_name = null)
    {
        $returnType = '\ElasticEmail\Model\ExportLink';
        $request = $this->eventsExportPostRequest($event_types, $from, $to, $file_format, $compression_format, $file_name);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'eventsExportPost'
     *
     * @param  \ElasticEmail\Model\EventType[] $event_types Types of Events to return (optional)
     * @param  \DateTime $from Starting date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \DateTime $to Ending date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \ElasticEmail\Model\ExportFileFormats $file_format Format of the exported file (optional)
     * @param  \ElasticEmail\Model\CompressionFormat $compression_format FileResponse compression format. None or Zip. (optional)
     * @param  string $file_name Name of your file including extension. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function eventsExportPostRequest($event_types = null, $from = null, $to = null, $file_format = null, $compression_format = null, $file_name = null)
    {

        $resourcePath = '/events/export';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($event_types !== null) {
            if('form' === 'form' && is_array($event_types)) {
                foreach($event_types as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['eventTypes'] = $event_types;
            }
        }
        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }
        // query params
        if ($file_format !== null) {
            if('form' === 'form' && is_array($file_format)) {
                foreach($file_format as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['fileFormat'] = $file_format;
            }
        }
        // query params
        if ($compression_format !== null) {
            if('form' === 'form' && is_array($compression_format)) {
                foreach($compression_format as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['compressionFormat'] = $compression_format;
            }
        }
        // query params
        if ($file_name !== null) {
            if('form' === 'form' && is_array($file_name)) {
                foreach($file_name as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['fileName'] = $file_name;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-ElasticEmail-ApiKey');
        if ($apiKey !== null) {
            $headers['X-ElasticEmail-ApiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation eventsGet
     *
     * Load Events
     *
     * @param  \ElasticEmail\Model\EventType[] $event_types Types of Events to return (optional)
     * @param  \DateTime $from Starting date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \DateTime $to Ending date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \ElasticEmail\Model\EventsOrderBy $order_by order_by (optional)
     * @param  int $limit How many items to load. Maximum for this request is 1000 items (optional)
     * @param  int $offset How many items should be returned ahead. (optional)
     *
     * @throws \ElasticEmail\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ElasticEmail\Model\RecipientEvent[]
     */
    public function eventsGet($event_types = null, $from = null, $to = null, $order_by = null, $limit = null, $offset = null)
    {
        list($response) = $this->eventsGetWithHttpInfo($event_types, $from, $to, $order_by, $limit, $offset);
        return $response;
    }

    /**
     * Operation eventsGetWithHttpInfo
     *
     * Load Events
     *
     * @param  \ElasticEmail\Model\EventType[] $event_types Types of Events to return (optional)
     * @param  \DateTime $from Starting date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \DateTime $to Ending date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \ElasticEmail\Model\EventsOrderBy $order_by (optional)
     * @param  int $limit How many items to load. Maximum for this request is 1000 items (optional)
     * @param  int $offset How many items should be returned ahead. (optional)
     *
     * @throws \ElasticEmail\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ElasticEmail\Model\RecipientEvent[], HTTP status code, HTTP response headers (array of strings)
     */
    public function eventsGetWithHttpInfo($event_types = null, $from = null, $to = null, $order_by = null, $limit = null, $offset = null)
    {
        $request = $this->eventsGetRequest($event_types, $from, $to, $order_by, $limit, $offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\ElasticEmail\Model\RecipientEvent[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\ElasticEmail\Model\RecipientEvent[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\ElasticEmail\Model\RecipientEvent[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ElasticEmail\Model\RecipientEvent[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation eventsGetAsync
     *
     * Load Events
     *
     * @param  \ElasticEmail\Model\EventType[] $event_types Types of Events to return (optional)
     * @param  \DateTime $from Starting date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \DateTime $to Ending date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \ElasticEmail\Model\EventsOrderBy $order_by (optional)
     * @param  int $limit How many items to load. Maximum for this request is 1000 items (optional)
     * @param  int $offset How many items should be returned ahead. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventsGetAsync($event_types = null, $from = null, $to = null, $order_by = null, $limit = null, $offset = null)
    {
        return $this->eventsGetAsyncWithHttpInfo($event_types, $from, $to, $order_by, $limit, $offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation eventsGetAsyncWithHttpInfo
     *
     * Load Events
     *
     * @param  \ElasticEmail\Model\EventType[] $event_types Types of Events to return (optional)
     * @param  \DateTime $from Starting date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \DateTime $to Ending date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \ElasticEmail\Model\EventsOrderBy $order_by (optional)
     * @param  int $limit How many items to load. Maximum for this request is 1000 items (optional)
     * @param  int $offset How many items should be returned ahead. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function eventsGetAsyncWithHttpInfo($event_types = null, $from = null, $to = null, $order_by = null, $limit = null, $offset = null)
    {
        $returnType = '\ElasticEmail\Model\RecipientEvent[]';
        $request = $this->eventsGetRequest($event_types, $from, $to, $order_by, $limit, $offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'eventsGet'
     *
     * @param  \ElasticEmail\Model\EventType[] $event_types Types of Events to return (optional)
     * @param  \DateTime $from Starting date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \DateTime $to Ending date for search in YYYY-MM-DDThh:mm:ss format. (optional)
     * @param  \ElasticEmail\Model\EventsOrderBy $order_by (optional)
     * @param  int $limit How many items to load. Maximum for this request is 1000 items (optional)
     * @param  int $offset How many items should be returned ahead. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function eventsGetRequest($event_types = null, $from = null, $to = null, $order_by = null, $limit = null, $offset = null)
    {

        $resourcePath = '/events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($event_types !== null) {
            if('form' === 'form' && is_array($event_types)) {
                foreach($event_types as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['eventTypes'] = $event_types;
            }
        }
        // query params
        if ($from !== null) {
            if('form' === 'form' && is_array($from)) {
                foreach($from as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['from'] = $from;
            }
        }
        // query params
        if ($to !== null) {
            if('form' === 'form' && is_array($to)) {
                foreach($to as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['to'] = $to;
            }
        }
        // query params
        if ($order_by !== null) {
            if('form' === 'form' && is_array($order_by)) {
                foreach($order_by as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['orderBy'] = $order_by;
            }
        }
        // query params
        if ($limit !== null) {
            if('form' === 'form' && is_array($limit)) {
                foreach($limit as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['limit'] = $limit;
            }
        }
        // query params
        if ($offset !== null) {
            if('form' === 'form' && is_array($offset)) {
                foreach($offset as $key => $value) {
                    $queryParams[$key] = $value;
                }
            }
            else {
                $queryParams['offset'] = $offset;
            }
        }




        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-ElasticEmail-ApiKey');
        if ($apiKey !== null) {
            $headers['X-ElasticEmail-ApiKey'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
